import { redis } from "../lib/redis.js";
import User from "../models/user.models.js";
import jwt from "jsonwebtoken";

const generateTokens = (userId) => {
  const accessToken = jwt.sign({ userId }, process.env.ACCESS_TOKEN_SECRET, {
    expiresIn: "15m", // for short duration
  });

  const refreshToken = jwt.sign({ userId }, process.env.REFRESH_TOKEN_SECRET, {
    expiresIn: "7d",
  });

  return { accessToken, refreshToken };
};

// now save the refresh token in the DB
const storeRefreshToken = async (userId, refreshToken) => {
  await redis.set(
    `refresh_token:${userId}`,
    refreshToken,
    "EX",
    7 * 24 * 60 * 60
  ); // expires in (EX) 7 days
};

const setCookies = (res, accessToken, refreshToken) => {
  res.cookie("access-token", accessToken, {
    // access-token is the key name. And accessToken is token value
    httpOnly: true, // this is preventing an attack call called, XSS (cross site scripting) attack  (security)
    // means, this cookie cannot be accesse via javaScript.. this is only gonna be true in production coz in development it's http and in production it's https (secure)
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict", // prevents from CSRF attack, Cross Site Reques Forgery
    maxAge: 15 * 60 * 1000, // expire in 15 mins
  });

  res.cookie("refresh-token", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });
};

export const signup = async (req, res) => {
  // desktop app => postman (go to postman - 32:05)
  // POSTMAN - create new workspace > name it > create a new collection > name it > "add request" > name it > change the http method to "post" (same as in auth.routes.js)

  // if the user wants to signup, they'll need Email, Name, Password. And we need to grab them. So this is how we call it
  const { email, password, name } = req.body; // (getting it from user)

  try {
    // we have to check if the user is in the DB or not
    const userExists = await User.findOne({ email }); // User - from user.model.js

    if (userExists) {
      return res.status(400).json({ message: "User already exists" });
    }
    // else
    const user = await User.create({ name, email, password }) // this password will be hashed coz before we save it to the DB, userSchema.pre (from user.model.js) will run!

    // authentication  (we saved the user to the DB but we didn't authenticate them)
    // creating access token (short lived eg:-15min) and refresh token (eg:- 7days)
    // we'll save both the tokens to in the cookie to check temporarily user is authenticated or not
    // And we'll also save the Refresh token to the Redis (Redis is often used for caching web pages, reducing load on servers and improving page loading times.) DB

    // Goto unsplash -> Redis (link given discptn)
    const { accessToken, refreshToken } = generateTokens(user._id); // id, generated by mongoose Atlas
    await storeRefreshToken(user._id, refreshToken);

    // NOW SETTING BOTH THE TOKENS IN COOKIES (refer diagram)
    setCookies(res, accessToken, refreshToken);

    res.status(201).json({
      user: {
        // sending the response to the client
        _id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
      },
      message: "User created successfully",
    }); // 201 -> something's created
  } catch (error) {
    console.log("signup in login controller", error.message);
    res.status(500).json({ message: error.message });
  }
}; // 56:30  - check in POSTMAN -> goto cookies
// access token expires in every 15 mins, which makes it secure   (IMP:: 58:05)
// ATTACKER can attack ===>>>  that's why it's imp to constantly expire access token and create a new one w refresh token

// after all this goto POSTMAN:- "https://localhost:5000/api/auth/signup" > body > raw > { "name": "John" } > it'll show error "add email and password also" > { "name": "Nick", "email": "nick@gmail.com", "password": "123456" }
// it'll show all the things we've modelled (in json format).
// And the password shown there should be   HASHED

// go to Atlas =>  database -> we got the data in json format after doing all the above things (Hashed password too). We can manually change "role" into "admin"





export const login = async (req, res) => {  
  try{
    const { email, password } = req.body    // email, password - coz user wants to login with them
    const user = await User.findOne({email})
    console.log(res);
    

    if(user && (await user.comparePassword(password))) {
        const {accessToken, refreshToken} = generateTokens(user._id);
        console.log(accessToken);
        
        await storeRefreshToken(user._id, refreshToken)  // storing
        setCookies(res, accessToken, refreshToken)

        res.json({
            _id: user._id,
            name: user.name,
            email: user.email,
            role: user.role,
        })
    } else {  // was showing error in POSTMAN thst's y added else part
        res.status(401).json({ message: "Invalid email or password" })
    }
  } catch (error) {
    console.log("Error in login controller", error.message);
    res.status(501).json({ message: error.message });
  }
  
};
// POSTMAN - change the password intentionlly wrong. It will show error on comparision of passwords stored in DB and the password which user is entering




export const logout = async (req, res) => {
//   res.send("logout route called");

// deleting the refresh token from Redis
try{
   const refreshToken = req.cookies.refresh-token;    // 01:01:02  - to be able to grab this refreshToken (from req.cookies.refreshToken), import middleware in server.js
   if(refreshToken) {
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);  // we have to decode it coz we have the userID into it
    await redis.del(`refresh_token: ${decoded.userId}`)
   }

   // now clearing both the tokens from cookie
   res.clearCookie("accessToken");
   res.clearCookie("refreshToken");
   res.json({ message: "Logged out successfully" });  // POSTMAN: 1:04:09
} catch (error) {
    console.log("Error in logout controller", error.message);
    res.status(500).json({ message: "Server error", error: error.message})
}
};

// this will refresh the access token  (as the access token will expire in every 15 mins, we want to re create it: the new one). 
// For that, we need to pass the refresh token
export  const refreshToken = async (req, res) => {
    try{
     const refreshToken = req.cookies.refreshToken;

     if(!refreshToken) {  // if refreshToken is not provided
      return res.status(404).json({ message: "No refresh token provided"})
     }
     // else
     const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET)  // decoding
     const storedToken = await redis.get(`refresh-token: ${decoded.userId}`)  // storing

     if(storedToken !== refreshToken) {
        return res.status(401).json({ message: "Invalid refresh token" })
     }

     const accessToken = jwt.sign({ userId: decoded.userId }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: "15m" })

     res.cookie("accessToken", accessToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        maxAge: 15*60*1000,
     })  // setting it to the cookie as the previous cookie is expired 

     res.json({message: "Token refresh successfully"})
    } catch (error) {
        console.log("Error in refreshToken controller", error.message)
        res.status(500).json({ message: "Server error", error: error.message})
    }
    // POSTMAN - 1:15:50
};



export const getProfile = async (req, res) => {
	try {
		res.json(req.user);
	} catch (error) {
		res.status(500).json({ message: "Server error", error: error.message });
	}
};
